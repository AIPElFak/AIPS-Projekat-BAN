function drawTable(e, a, r, t, s, i, n, o) { var l = 30, d = e, h = 3 * d, p = 3 * d / 2, c = d / 250, u = 0, B = 0, A = 30, C = d / 31250, m = []; d = drawElipticWraper(l, d, h, p, c, u, B, A, C, m), B += c * A, d = drawElipticWraper(l, d, h = 3 * d, p, c = d / 2500, u = d / 2500, B, A = 10, C, m), B += c * A, d = drawElipticWraper(l, d, h = 3 * d, p, c = d / 2777, u = d / 3571, B, A = 15, C, m), B += c * A, d = drawElipticWraper(l, d, h = 3 * d, p, c = d / 25e3, u = d / 2857, B, A = 15, C, m), B += c * A, d = drawElipticWraper(l, d, h = 3 * d, p, c = -d / 25e3, u = d / 2857, B, A = 15, C, m), B += c * A, d = drawElipticWraper(l, d, h = 3 * d, p, c = -d / 2777, u = d / 3571, B, A = 15, C, m), B += c * A; var w = []; h = 3 * (d = drawElipticWraper(l, d, h = 3 * d, p, c = -d / 250, u = 0, B, A = 17, C, w)), B += c * A, A = 17, u = d / 680, c = -d / 2500, m.push(w[0]), BABYLON.Mesh.CreateRibbon("rib", m, !1, !1, 0, scene).material = a, d = drawElipticWraper(l, d, h, p, c, u, B, A, C, w), BABYLON.Mesh.CreateRibbon("rib2", w, !1, !1, 0, scene).material = r; var y = []; h = 3.1 * (d += u), p = 2 * d; for (var L = l = 30; L >= 0; L--) { for (var f = [], O = 0; O <= 1; O++) { var v = p * Math.cos(Math.PI - L * Math.PI / l), P = B, M = h / 2 + p * Math.sin(Math.PI - L * Math.PI / l); 1 == O && (M *= -1), f.push(new BABYLON.Vector3(v, P, M)) } y.push(f) } BABYLON.Mesh.CreateRibbon("rib3", y, !1, !1, 0, scene).material = t, drawAllPlayingCardPositions(1.3 * d, B, h, p), drawAllPlayingChipPositions(d, B, h, p), drawAllAvatars(d, B, h, p) } function drawElipticWraper(e, a, r, t, s, i, n, o, l, d) { for (var h = 0; h < o; ++h) { t = 2 * a; for (var p = [], c = e; c >= 0; c--)for (var u = 0; u <= 1; u++) { var B = t * Math.cos(Math.PI - c * Math.PI / e), A = n + s, C = r / 2 + t * Math.sin(Math.PI - c * Math.PI / e); 0 == u ? (C *= -1, p[e - c] = new BABYLON.Vector3(B, A, C)) : p[e + 1 + c] = new BABYLON.Vector3(B, A, C) } var B = t, A = n + s, C = -r / 2; n += s, a -= i, i += l, p[2 * e + 2] = new BABYLON.Vector3(B, A, C), d.push(p) } return a } function drawElipticBase(e, a, r, t) { for (var s = [], i = e; i >= 0; i--) { for (var n = [], o = 0; o <= 1; o++) { var l = a * Math.cos(Math.PI - i * Math.PI / e), d = r, h = t / 2 + a * Math.sin(Math.PI - i * Math.PI / e); 0 == o && (h *= -1), n.push(new BABYLON.Vector3(l, d, h)) } s.push(n) } for (var p = new Array(2 * e + 1), c = -a, u = a - c, B = t / 2 + a, A = -B, C = B - A, m = 0; m < e + 1; ++m) { var w = (s[m][0].x - c) / u, y = (s[m][0].z - A) / C, L = (s[m][1].x - c) / u, f = (s[m][1].z - A) / C; p[2 * m] = new BABYLON.Vector2(w, y), p[2 * m + 1] = new BABYLON.Vector2(L, f) } return BABYLON.MeshBuilder.CreateRibbon("rib", { pathArray: s, sideOrientation: BABYLON.Mesh.DOUBLESIDE, offset: 0, uvs: p, invertUV: !0 }, scene) } var model = { cardTextures: [], chipTextures: [], playerCards: new Array, tableCards: new Array, playerChips: new Array, tableChips: new Array, playerMoney: new Array, playerMoneyAmount: new Array, playerChipAmount: new Array, playerStakes: new Array, avatars: new Array, tableChipAmount: 0, noShownCards: 0, camera: 0, sounds: new Array, init: function () { this.sounds.raise = new Audio("../Content/sounds/raise.mp3"), this.sounds.fold = new Audio("../Content/sounds/fold.mp3"), this.sounds.check = new Audio("../Content/sounds/check.mp3"), this.sounds.flop = new Audio("../Content/sounds/flop.mp3"), this.sounds.wait = new Audio("../Content/sounds/wait.mp3") }, setAvatar: function (e, a) { "undefined" != this.avatars[e].material && this.avatars[e].material.dispose(), this.avatars[e].material = new BABYLON.StandardMaterial(e + "avatar", scene), this.avatars[e].material.diffuseTexture = new BABYLON.Texture(a, scene), this.avatars[e].material.diffuseTexture.hasAlpha = !0, this.avatars[e].material.emissiveColor = new BABYLON.Color3(1, 1, 1), this.avatars[e].setEnabled(1) }, removeAvatar: function (e) { var a = avatars[e]; a.material.dispose(), a.setEnabled(0) }, getCardTexture: function (e) { if (void 0 === this.cardTextures[e]) { var a = new BABYLON.StandardMaterial(e, scene); a.alpha = 1, a.diffuseColor = new BABYLON.Color3(1, 1, 1), a.backFaceCulling = !1, a.diffuseTexture = new BABYLON.Texture("../Scripts/textures/" + e + ".png", scene), this.cardTextures[e] = a } return this.cardTextures[e] }, changePlayerChipAmount: function (e, a) { this.setPlayerChips(e, a + this.playerChipAmount[e]) }, getChipTexture: function (e) { if (void 0 === this.chipTextures[e]) { var a = new BABYLON.StandardMaterial(e, scene); a.alpha = 1, a.diffuseColor = new BABYLON.Color3(1, 1, 1), a.backFaceCulling = !1, a.diffuseTexture = new BABYLON.Texture("../Scripts/textures/" + e + ".png", scene), this.chipTextures[e] = a } return this.chipTextures[e] }, setPlayerCards: function (e, a, r) { this.playerCards[e][0].setEnabled(1), this.playerCards[e][0].material = this.getCardTexture(a), this.playerCards[e][1].setEnabled(1), this.playerCards[e][1].material = this.getCardTexture(r) }, setTableCard: function (e, a) { this.tableCards[e].setEnabled(1), this.tableCards[e].material = this.getCardTexture(a) }, setPlayerMoney: function (e, a) { this.playerMoney[e] = a }, setPlayerChips: function (e, a) { var r = this.findChipsForSum(a, 20); this.playerChipAmount[e] = a; for (var t = 0; t < 20; ++t)void 0 === r[t] ? (this.playerChips[e][t][0].setEnabled(0), this.playerChips[e][t][1].setEnabled(0), this.playerChips[e][t][2].setEnabled(0)) : (this.playerChips[e][t][0].setEnabled(1), this.playerChips[e][t][1].setEnabled(1), this.playerChips[e][t][2].setEnabled(1), this.playerChips[e][t][0].material = this.getChipTexture("" + r[t]), this.playerChips[e][t][1].material = this.getChipTexture("" + r[t]), this.playerChips[e][t][2].material = this.getChipTexture("" + r[t])); setStakes(e, a) }, setTableChips: function (e) { var a = this.findChipsForSum(e, 20); this.tableChipAmount = e; for (var r = 0; r < 20; ++r)void 0 === a[r] ? (this.playerChips[8][r][0].setEnabled(0), this.playerChips[8][r][1].setEnabled(0), this.playerChips[8][r][2].setEnabled(0)) : (this.playerChips[8][r][0].setEnabled(1), this.playerChips[8][r][1].setEnabled(1), this.playerChips[8][r][2].setEnabled(1), this.playerChips[8][r][0].material = this.getChipTexture("" + a[r]), this.playerChips[8][r][1].material = this.getChipTexture("" + a[r]), this.playerChips[8][r][2].material = this.getChipTexture("" + a[r])); setStakes(8, e) }, changeTableChips: function (e) { this.setTableChips(this.tableChipAmount + e) }, resetSceen: function () { this.noShownCards = 0, this.setTableChips(0); for (e = 0; e < 8; ++e)this.setPlayerChips(e, 0), this.playerCards[e][0].setEnabled(0), this.playerCards[e][1].setEnabled(0); for (var e = 0; e < 5; ++e)this.tableCards[e].setEnabled(0) }, findChipsForSum: function (e, a) { for (var r = [100, 500, 1e3, 5e3, 25e3, 1e5, 25e4, 5e5, 1e6], t = [], s = 0, i = 8, n = e; 0 != n && s != a && i >= 0;)n >= r[i] ? (n -= r[i], t.push(r[i]), s++) : i--; return t }, eliminatePlayer: function (e) { this.setPlayerChips(e, 0), this.playerCards[e][0].setEnabled(0), this.playerCards[e][1].setEnabled(0) } }, setTableCard = function (e, a) { if (model.noShownCards <= e) { var r = 500; 2 !== e && 3 !== e || (r *= e), setTimeout(function (e, a) { model.setTableCard(e, a), model.sounds.flop.play(), pileUp() }, r, e, a), model.noShownCards++ } }, setPlayerChips = function (e, a) { model.changePlayerChipAmount(e, a) }, resetPlayerChips = function () { for (var e = 0; e < 8; ++e)model.setPlayerChips(e, 0) }, setPlayerTableChips = function (e, a) { PlayerTableChips[e] = a }, setPlayerCard = function (e, a, r) { model.setPlayerCards(e, a, r) }, setPlayerStats = function (e, a, r, t) { Usernames[a] = e, model.setAvatar(a, t), PlayerTableChips[a] = r }, positionPlayer = function (e) { myPositon = e, e < 2 || e > 5 ? (model.camera.setPosition(new BABYLON.Vector3(-50, 45, 0)), model.avatars[2].position.y *= 3.5, model.avatars[3].position.y *= 3.5, model.avatars[4].position.y *= 3.5, model.avatars[5].position.y *= 3.5) : (model.avatars[0].position.y *= 3.5, model.avatars[1].position.y *= 3.5, model.avatars[6].position.y *= 3.5, model.avatars[7].position.y *= 3.5) }, playMan = function (e, a, r) { enableButtons(); var t = document.getElementById("call"); t.innerHTML = 0 == a ? "Check" : "Call " + a; var s = document.getElementsByClassName("irs-min"), i = document.getElementsByClassName("irs-max"); s[0].innerHTML = r, i[0].innerHTML = PlayerTableChips[e] - a, timer = setTimeout(commitAction, 15e3), model.sounds.wait.play() }, commitAction = function () { if (readyToPlay) model.sounds.wait.pause(), model.sounds.wait.currentTime = 0, clearTimeout(timer), readyToPlay = !1, gameHub.server.play(raiseAmount, gameModel.gameName), raiseAmount < 0 && model.sounds.fold.play(), 0 == raiseAmount && model.sounds.check.play(), raiseAmount > 0 && model.sounds.raise.play(); else { model.sounds.wait.pause(), model.sounds.wait.currentTime = 0; var e = document.getElementById("call"); "Check" == e.innerHTML ? (gameHub.server.play(0, gameModel.gameName), model.sounds.check.play()) : (e.innerHTML = "Check", gameHub.server.play(-1, gameModel.gameName), model.sounds.fold.play()) } }, displayMove = function (e, a) { a < 0 ? (model.eliminatePlayer(e), model.sounds.fold.play()) : (model.changePlayerChipAmount(e, a), PlayerChips[e] += a, 0 === a ? model.sounds.check.play() : model.sounds.raise.play()) }, pileUp = function () { for (var e = 0, a = 0; a < 8; ++a)e += model.playerChipAmount[a], model.setPlayerChips(a, 0); model.changeTableChips(e) }, resetSceen = function () { model.resetSceen() }, showWinner = function (e) { }; myPositon = 0; var canvas = document.querySelector("#renderCanvas"), engine = new BABYLON.Engine(canvas, !0), timer, TableCards = new Array(5), PlayerCards = new Array(16), Usernames = new Array(8), PlayerTableChips = [0, 0, 0, 0, 0, 0, 0, 0], PlayerChips = [0, 0, 0, 0, 0, 0, 0, 0], PileChips = 0, activePlayers = new Array(8), noShownCards = 0, readyToPlay = !1, raiseAmount = 0, scene = new BABYLON.Scene(engine); model.scene = scene, model.init(); var drawAllPlayingCardPositions = function (e, a, r, t) { drawAParOfCCards(e, a, .8 * t, .3 * -r, Math.PI, 0), drawAParOfCCards(e, a, .8 * t, .3 * r, Math.PI, 7), drawAParOfCCards(e, a, .8 * t, -r / 2, 11 * Math.PI / 15, 1), drawAParOfCCards(e, a, .8 * t, r / 2, 11 * -Math.PI / 15, 6), drawAParOfCCards(e, a, .8 * t, -r / 2, 6 * Math.PI / 15, 2), drawAParOfCCards(e, a, .8 * t, r / 2, 6 * -Math.PI / 15, 5), drawAParOfCCards(e, a, .8 * t, -r / 2, Math.PI / 15, 3), drawAParOfCCards(e, a, .8 * t, r / 2, -Math.PI / 15, 4) }, drawAParOfCCards = function (e, a, r, t, s, i) { var n = drawCardPosition(e), o = drawCardPosition(e); n.rotate(BABYLON.Axis.Y, s, BABYLON.Space.LOCAL), n.translate(new BABYLON.Vector3(r, 0, 0), 1, BABYLON.Space.LOCAL), n.translate(new BABYLON.Vector3(0, 0, t), 1, BABYLON.Space.WORLD), n.translate(new BABYLON.Vector3(0, 1.1 * a, .115 * -e), 1, BABYLON.Space.LOCAL), n.rotate(BABYLON.Axis.Y, .8 * Math.PI / 2, BABYLON.Space.LOCAL), o.rotate(BABYLON.Axis.Y, s, BABYLON.Space.LOCAL), o.translate(new BABYLON.Vector3(r, 0, 0), 1, BABYLON.Space.LOCAL), o.translate(new BABYLON.Vector3(0, .1, t), 1, BABYLON.Space.WORLD), o.translate(new BABYLON.Vector3(0, 1.1 * a, .115 * e), 1, BABYLON.Space.LOCAL), o.rotate(BABYLON.Axis.Y, 1.2 * Math.PI / 2, BABYLON.Space.LOCAL), model.playerCards[i] = new Array, model.playerCards[i][0] = n, model.playerCards[i][1] = o }, drawCardPosition = function (e) { for (var a = [], r = e / 45, t = 11 * r, s = 20 * r, i = 1.4 * r, n = 10; n >= 0; n--) { for (var o = [], l = 0; l <= 1; l++) { var d = (t - 2 * i) / 2 + i * Math.cos(Math.PI / 2 - n * Math.PI / 20), h = 0, p = s / 2 + i * Math.sin(Math.PI / 2 - n * Math.PI / 20); 0 == l && (p *= -1), o.push(new BABYLON.Vector3(d, h, p)) } a.push(o) } for (n = 10; n >= 0; n--) { for (var o = [], l = 0; l <= 1; l++) { var d = -t / 2 + i * Math.cos(Math.PI - n * Math.PI / 20), h = 0, p = s / 2 + i * Math.sin(Math.PI - n * Math.PI / 20); 0 == l && (p *= -1), o.push(new BABYLON.Vector3(d, h, p)) } a.push(o) } for (var c = new Array(21), u = -t / 2 - i, B = (t - 2 * i) / 2 + i - u, A = s / 2 + i, C = -A, m = A - C, w = 0; w < 22; ++w) { var y = (a[w][0].x - u) / B, L = (a[w][0].z - C) / m, f = (a[w][1].x - u) / B, O = (a[w][1].z - C) / m; c[2 * w] = new BABYLON.Vector2(y, L), c[2 * w + 1] = new BABYLON.Vector2(f, O) } return BABYLON.MeshBuilder.CreateRibbon("rib", { pathArray: a, sideOrientation: BABYLON.Mesh.DOUBLESIDE, offset: 0, uvs: c, invertUV: !0 }, scene) }, drawTableCards = function (e) { for (var a = 0; a < 5; ++a) { var r = drawCardPosition(e); r.rotate(BABYLON.Axis.Y, Math.PI / 2, BABYLON.Space.LOCAL), r.translate(new BABYLON.Vector3(e / 2 * a - e, .1 * e, 0), 1, BABYLON.Space.LOCAL), model.tableCards[a] = r } }, drawAvatar = function (e, a, r, t, s) { var i = .8 * e, n = BABYLON.Mesh.CreatePlane("plane" + s, i, scene, !1, BABYLON.Mesh.DOUBLESIDE); n.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_ALL, n.material = new BABYLON.StandardMaterial("outputplane" + s, scene), n.position = new BABYLON.Vector3(a, r, t), n.setEnabled(0), model.avatars[s] = n; n.position }, drawAllAvatars = function (e, a, r, t) { drawAvatar(e, 2.6 * -e, .089973 * e, -.916 * e, 0), drawAvatar(e, 2.6 * -e, .089973 * e, .916 * e, 7), drawAvatar(e, 1.73974 * -e, .089973 * e, -3.43066 * e, 1), drawAvatar(e, 1.73974 * -e, .089973 * e, 3.43066 * e, 6), drawAvatar(e, .80344 * e, .089973 * e, -3.96073 * e, 2), drawAvatar(e, .80344 * e, .089973 * e, 3.96073 * e, 5), drawAvatar(e, 2.54318 * e, .089973 * e, -2.06608 * e, 3), drawAvatar(e, 2.54318 * e, .089973 * e, 2.06608 * e, 4) }, drawAllPlayingChipPositions = function (e, a, r, t) { var s = e / 19; drawChipPile(s, a, .8 * t, .3 * -r, Math.PI, 0), drawChipPile(s, a, .8 * t, .3 * r, Math.PI, 7), drawChipPile(s, a, .8 * t, -r / 2, 11 * Math.PI / 15, 1), drawChipPile(s, a, .8 * t, r / 2, 11 * -Math.PI / 15, 6), drawChipPile(s, a, .8 * t, -r / 2, 6 * Math.PI / 15, 2), drawChipPile(s, a, .8 * t, r / 2, 6 * -Math.PI / 15, 5), drawChipPile(s, a, .8 * t, -r / 2, Math.PI / 15, 3), drawChipPile(s, a, .8 * t, r / 2, -Math.PI / 15, 4), drawChipPile(s, a, .6 * -e, 0, 0, 8) }, drawChip = function (e) { var a = e, r = 3 * a / 2, t = a / 50, s = 0, i = 0, n = 30, o = [], l = drawElipticBase(30, r = 2 * a, i, 0); a = drawElipticWraper(30, a, 0, r = 3 * a / 2, t, s, i, n, 0, o), i += t * n, a = drawElipticWraper(30, a, 0, r, t = a / 2777, s = 0, i, n = 15, 0, o); var d = BABYLON.Mesh.CreateRibbon("rib", o, !1, !1, 0, scene), h = drawElipticBase(30, r = 2 * a, i, 0), p = []; return p.push(d), p.push(l), p.push(h), p }, drawChipPile = function (e, a, r, t, s, i) { var n, o = [0, 4 * e, 3.5 * e, 7.5 * e], l = [0, 2 * -e, 2.5 * e, .5 * e]; model.playerChips[i] = new Array; for (var d = 0; d < 4; ++d)0 == d ? n = drawStackOfChips(0, e, 5, a, r, t, s - 3 * Math.PI / 30, o[d], l[d], i) : drawStackOfChips(d, e, 5, a, r, t, s - 3 * Math.PI / 30, o[d], l[d], i); var h = drawChipAmount(e); h.position = n[0].position, h.translate(new BABYLON.Vector3(0, 6 * e, 0), 1, BABYLON.Space.LOCAL), model.playerStakes[i] = h }, drawStackOfChips = function (e, a, r, t, s, i, n, o, l, d) { for (var h, p = 0, c = !0, u = 0; u < r; ++u) { var B = drawChip(a); c && (h = B, c = !1), model.playerChips[d][e * r + u] = new Array; for (var A = 0; A < 3; ++A)B[A].rotate(BABYLON.Axis.Y, n, BABYLON.Space.LOCAL), B[A].translate(new BABYLON.Vector3(0, p, 0), 1, BABYLON.Space.LOCAL), B[A].translate(new BABYLON.Vector3(s, 0, 0), 1, BABYLON.Space.LOCAL), B[A].translate(new BABYLON.Vector3(0, 0, i), 1, BABYLON.Space.WORLD), B[A].translate(new BABYLON.Vector3(l, 1.1 * t, .115 * -a + o), 1, BABYLON.Space.LOCAL), model.playerChips[d][e * r + u].push(B[A]); p += .75 * a } return h }, findChipsForSum = function (e, a) { for (var r = [100, 500, 1e3, 5e3, 25e3, 1e5, 25e4, 5e5, 1e6], t = [], s = 0, i = 8, n = e; 0 != n && s != a && i >= 0;)n >= r[i] ? (n -= r[i], t.push(r[i]), s++) : i--; return t }, drawChipAmount = function (e) { for (var a = 1.5 * e, r = { height: 512, width: 5325 }, t = (new BABYLON.DynamicTexture("dynamic texture", r, scene, !0), []), s = 5 * (e = a / 5) * 15, i = 10 * e, n = 1.4 * e, o = 10; o >= 0; o--) { for (var l = [], d = 0; d <= 1; d++) { var h = (s - 2 * n) / 2 + n * Math.cos(Math.PI / 2 - o * Math.PI / 20), p = 0, c = i / 2 + n * Math.sin(Math.PI / 2 - o * Math.PI / 20); 0 == d && (c *= -1), l.push(new BABYLON.Vector3(h, c, p)) } t.push(l) } for (o = 10; o >= 0; o--) { for (var l = [], d = 0; d <= 1; d++) { var h = -s / 2 + n * Math.cos(Math.PI - o * Math.PI / 20), p = 0, c = i / 2 + n * Math.sin(Math.PI - o * Math.PI / 20); 0 == d && (c *= -1), l.push(new BABYLON.Vector3(h, c, p)) } t.push(l) } for (var u = new Array(21), B = -s / 2 - n, A = (s - 2 * n) / 2 + n - B, C = i / 2 + n, m = -C, w = C - m, y = 0; y < 22; ++y) { var L = (t[y][0].x - B) / A, f = (t[y][0].y - m) / w, O = (t[y][1].x - B) / A, v = (t[y][1].y - m) / w; u[2 * y] = new BABYLON.Vector2(L, f), u[2 * y + 1] = new BABYLON.Vector2(O, v) } var P = BABYLON.MeshBuilder.CreateRibbon("rib", { pathArray: t, sideOrientation: BABYLON.Mesh.DOUBLESIDE, offset: 0, uvs: u, invertUV: !0 }, scene); return P.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_ALL, P.material = new BABYLON.StandardMaterial("outputplane", scene), P.material.emissiveColor = new BABYLON.Color3(1, 1, 1), P.material.diffuseTexture = new BABYLON.DynamicTexture("dynamic texture", r, scene, !0), P.material.diffuseTexture.drawText("", null, 450, "bold 500px verdana", "white"), P.material.diffuseTexture.hasAlpha = !0, P }, setStakes = function (e, a) { model.playerStakes[e].material.diffuseTexture.getContext().clearRect(0, 0, 5325, 5325), 0 != a ? model.playerStakes[e].material.diffuseTexture.drawText("$" + a, null, 450, "bold 500px verdana", "white") : model.playerStakes[e].material.diffuseTexture.update() }, createScene = function () { scene.clearColor = new BABYLON.Color3(0, 0, .1445), model.camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene), model.camera.setPosition(new BABYLON.Vector3(50, 45, 0)), new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 1), scene).intensity = .9; var e = new BABYLON.StandardMaterial("mat1", scene); e.alpha = 1, e.diffuseColor = new BABYLON.Color3(.2067, .0432, .0432), e.backFaceCulling = !1; var a = new BABYLON.StandardMaterial("mat2", scene); a.alpha = 1, a.diffuseColor = new BABYLON.Color3(.4, .298, .0314), a.backFaceCulling = !1; var r = new BABYLON.StandardMaterial("mat3", scene); r.alpha = 1, r.diffuseColor = new BABYLON.Color3(.6863, .0824, .0824), r.backFaceCulling = !1; return drawTable(9, e, a, r), drawTableCards(9 * 1.3), scene }, scene = createScene(); engine.runRenderLoop(function () { scene.render() }), window.addEventListener("resize", function () { engine.resize() }), resetSceen();